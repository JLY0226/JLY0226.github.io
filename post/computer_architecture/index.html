<!doctype html>
<html lang="en-us">
  <head>
    <title>Computer_architecture // jly blog</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.125.1">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.5b1fcc8902588589c4767187402a3c29f8b8d7a6fdef6d9f8f77045bb0d14fee.css" />
    

    
  


    <meta name="twitter:card" content="summary"><meta name="twitter:title" content="Computer_architecture">
<meta name="twitter:description" content="1 动态流水线技术的由来 为什么会发明动态流水线？首先我们来了解一下静态流水线的一个弊端，我们都知道简单的静态流水线，它们都是使用顺序指令发射与执行，一旦出现一条指令停顿在流水线中，后续的指令都不能执行，即使后面有些指令不依赖这条阻塞的指令，那也只能乖乖阻塞等待，效率大大降低，所以动态流水线应运而生。 举个简单的例子帮助理解：简单的静态流水线就像是一条单向单车道且无法超车，一旦前面的车出现车祸，那么后面所有的车都被堵住；而动态流水线就像是多车道，如果前面有一辆车出现车祸，其后面无关的车辆可以通过其他车道超车前进。
2 浅谈指令调度技术 什么叫做指令调度技术呢？指令调度技术的一个前提是不改变程序正确性，通过改变指令的执行次序来避免由于指令相关引起的流水线阻塞。
* 静态指令调度 由程序猿或者编译器在程序执行==之前==进行的指令调度，那多少有点废程序猿了。 主要的方法有哪些呢？ 1.循环展开——将来自不同迭代的指令放在一起调度，以此来消除数据使用停顿，但是如果代码规模比较大的话，导致cache的命中率会下降，而且可能导致寄存器紧缺。 2.寄存器重命名——可以消除WAW(写后写）和WAR(读后写）相关，但需要更多的寄存器。
* 动态指令调度 在程序执行==过程中==由==硬件==自动进行的指令调度，这不程序猿就可以早点下班了嘛，下面会具体介绍。
3 冒险 为什么放在这里介绍冒险呢？对，就是要提醒你一共有3种流水线冒险，其中数据冒险还有3种情况。
* 结构冒险 其实结构冒险可以先不管，因为不常见。在现代处理器中，结构冒险主要发生在不太常用的特殊用途功能单元（例如浮点除法）。
* 控制冒险 官方是这么说的：分支指令及其他改变程序计数器的指令实现流水化时可能导致控制冒险。 可能你看的云里雾里，稍微举个例子解释一下，就拿if语句来举例。
if p1{ s1; // s1控制依赖于p1 } if p2{ s2; // s2控制依赖于p2，但不控制依赖于p1 } 这个例子中，我们不能把s1中的一条指令拿出来移到这个if语句之前，因为s1是控制依赖于p1的；另外我们也不能把s2中的指令移到s1中，因为本来s2就不控制依赖于p1，移动的话就会产生控制依赖。
* 数据冒险 - RAW(写后读）又称==真相关==——本应该先写后读，但j试图在i写入一个源位置之前读取来该位置的值，则会导致j错误的读取了旧值。 - WAW(写后写) 又称==输出相关==——本应该先i写后j写，但j试图在i写一个操作数之前写这个操作数，也就是写入顺序出错，最后的结果出错。 - WAR(读后写）又称==反相关==——本应该先读后写，但j尝试在i读取一个操作数之前写这个操作数，导致结果出错。 4 动态调度 4.1 思想 动态调度，就是在指令的执行过程中，由硬件自动对指令的执行次序进行调度以避免由于数据相关引起的流水线阻塞。总结就一句话：==前面指令的阻塞不影响后面指令的继续前进。==
4.2 实现方法 先看一段代码：
fdiv.d f0 , f2 , f4 //浮点除法 fadd.d f10 , f0 , f8 //浮点加法 fsub.">

    <meta property="og:url" content="https://JLY0226.github.io/post/computer_architecture/">
  <meta property="og:site_name" content="jly blog">
  <meta property="og:title" content="Computer_architecture">
  <meta property="og:description" content="1 动态流水线技术的由来 为什么会发明动态流水线？首先我们来了解一下静态流水线的一个弊端，我们都知道简单的静态流水线，它们都是使用顺序指令发射与执行，一旦出现一条指令停顿在流水线中，后续的指令都不能执行，即使后面有些指令不依赖这条阻塞的指令，那也只能乖乖阻塞等待，效率大大降低，所以动态流水线应运而生。 举个简单的例子帮助理解：简单的静态流水线就像是一条单向单车道且无法超车，一旦前面的车出现车祸，那么后面所有的车都被堵住；而动态流水线就像是多车道，如果前面有一辆车出现车祸，其后面无关的车辆可以通过其他车道超车前进。
2 浅谈指令调度技术 什么叫做指令调度技术呢？指令调度技术的一个前提是不改变程序正确性，通过改变指令的执行次序来避免由于指令相关引起的流水线阻塞。
* 静态指令调度 由程序猿或者编译器在程序执行==之前==进行的指令调度，那多少有点废程序猿了。 主要的方法有哪些呢？ 1.循环展开——将来自不同迭代的指令放在一起调度，以此来消除数据使用停顿，但是如果代码规模比较大的话，导致cache的命中率会下降，而且可能导致寄存器紧缺。 2.寄存器重命名——可以消除WAW(写后写）和WAR(读后写）相关，但需要更多的寄存器。
* 动态指令调度 在程序执行==过程中==由==硬件==自动进行的指令调度，这不程序猿就可以早点下班了嘛，下面会具体介绍。
3 冒险 为什么放在这里介绍冒险呢？对，就是要提醒你一共有3种流水线冒险，其中数据冒险还有3种情况。
* 结构冒险 其实结构冒险可以先不管，因为不常见。在现代处理器中，结构冒险主要发生在不太常用的特殊用途功能单元（例如浮点除法）。
* 控制冒险 官方是这么说的：分支指令及其他改变程序计数器的指令实现流水化时可能导致控制冒险。 可能你看的云里雾里，稍微举个例子解释一下，就拿if语句来举例。
if p1{ s1; // s1控制依赖于p1 } if p2{ s2; // s2控制依赖于p2，但不控制依赖于p1 } 这个例子中，我们不能把s1中的一条指令拿出来移到这个if语句之前，因为s1是控制依赖于p1的；另外我们也不能把s2中的指令移到s1中，因为本来s2就不控制依赖于p1，移动的话就会产生控制依赖。
* 数据冒险 - RAW(写后读）又称==真相关==——本应该先写后读，但j试图在i写入一个源位置之前读取来该位置的值，则会导致j错误的读取了旧值。 - WAW(写后写) 又称==输出相关==——本应该先i写后j写，但j试图在i写一个操作数之前写这个操作数，也就是写入顺序出错，最后的结果出错。 - WAR(读后写）又称==反相关==——本应该先读后写，但j尝试在i读取一个操作数之前写这个操作数，导致结果出错。 4 动态调度 4.1 思想 动态调度，就是在指令的执行过程中，由硬件自动对指令的执行次序进行调度以避免由于数据相关引起的流水线阻塞。总结就一句话：==前面指令的阻塞不影响后面指令的继续前进。==
4.2 实现方法 先看一段代码：
fdiv.d f0 , f2 , f4 //浮点除法 fadd.d f10 , f0 , f8 //浮点加法 fsub.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
  <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-04-25T22:35:12+08:00">
    <meta property="article:modified_time" content="2024-04-25T22:35:12+08:00">


  </head>
  <body>
    <header class="app-header">
      <a href="https://JLY0226.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <span class="app-header-title">jly blog</span>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Computer_architecture</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Apr 25, 2024
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="1-动态流水线技术的由来">1 动态流水线技术的由来</h1>
<p>为什么会发明动态流水线？首先我们来了解一下静态流水线的一个弊端，我们都知道简单的静态流水线，它们都是使用顺序指令发射与执行，一旦出现一条指令停顿在流水线中，后续的指令都不能执行，即使后面有些指令不依赖这条阻塞的指令，那也只能乖乖阻塞等待，效率大大降低，所以动态流水线应运而生。
举个简单的例子帮助理解：简单的静态流水线就像是一条单向单车道且无法超车，一旦前面的车出现车祸，那么后面所有的车都被堵住；而动态流水线就像是多车道，如果前面有一辆车出现车祸，其后面无关的车辆可以通过其他车道超车前进。</p>
<h1 id="2-浅谈指令调度技术">2 浅谈指令调度技术</h1>
<p>什么叫做指令调度技术呢？指令调度技术的一个前提是<strong>不改变程序正确性</strong>，通过改变指令的<strong>执行次序</strong>来避免由于指令相关引起的流水线阻塞。</p>
<h3 id="-静态指令调度">* 静态指令调度</h3>
<p>由程序猿或者编译器在程序执行==之前==进行的指令调度，那多少有点废程序猿了。
主要的方法有哪些呢？
1.<em>循环展开</em>——将来自不同迭代的指令放在一起调度，以此来消除数据使用停顿，但是如果代码规模比较大的话，导致cache的命中率会下降，而且可能导致寄存器紧缺。
2.<em>寄存器重命名</em>——可以消除WAW(写后写）和WAR(读后写）相关，但需要更多的寄存器。</p>
<h3 id="-动态指令调度">* 动态指令调度</h3>
<p>在程序执行==过程中==由==硬件==自动进行的指令调度，这不程序猿就可以早点下班了嘛，下面会具体介绍。</p>
<h1 id="3-冒险">3 冒险</h1>
<p>为什么放在这里介绍冒险呢？对，就是要提醒你一共有3种流水线冒险，其中数据冒险还有3种情况。</p>
<h3 id="-结构冒险">* 结构冒险</h3>
<p>其实结构冒险可以先不管，因为不常见。在现代处理器中，结构冒险主要发生在不太常用的特殊用途功能单元（例如浮点除法）。</p>
<h3 id="-控制冒险">* 控制冒险</h3>
<p>官方是这么说的：分支指令及其他改变程序计数器的指令实现流水化时可能导致控制冒险。
可能你看的云里雾里，稍微举个例子解释一下，就拿if语句来举例。</p>
<pre tabindex="0"><code>if p1{
	s1;      // s1控制依赖于p1
}
if p2{
	s2;     // s2控制依赖于p2，但不控制依赖于p1
}
</code></pre><p>这个例子中，我们不能把s1中的一条指令拿出来移到这个if语句之前，因为s1是控制依赖于p1的；另外我们也不能把s2中的指令移到s1中，因为本来s2就不控制依赖于p1，移动的话就会产生控制依赖。</p>
<h3 id="-数据冒险">* 数据冒险</h3>
<h5 id="--raw写后读又称真相关本应该先写后读但j试图在i写入一个源位置之前读取来该位置的值则会导致j错误的读取了旧值">- RAW(写后读）又称==真相关==——本应该先写后读，但j试图在i写入一个源位置之前读取来该位置的值，则会导致j错误的读取了旧值。</h5>
<h5 id="--waw写后写--又称输出相关本应该先i写后j写但j试图在i写一个操作数之前写这个操作数也就是写入顺序出错最后的结果出错">- WAW(写后写)  又称==输出相关==——本应该先i写后j写，但j试图在i写一个操作数之前写这个操作数，也就是写入顺序出错，最后的结果出错。</h5>
<h5 id="--war读后写又称反相关本应该先读后写但j尝试在i读取一个操作数之前写这个操作数导致结果出错">- WAR(读后写）又称==反相关==——本应该先读后写，但j尝试在i读取一个操作数之前写这个操作数，导致结果出错。</h5>
<h1 id="4-动态调度">4 动态调度</h1>
<h2 id="41-思想">4.1 思想</h2>
<p><strong>动态调度</strong>，就是在指令的执行过程中，由<strong>硬件</strong>自动对指令的执行次序进行调度以避免由于数据相关引起的流水线阻塞。总结就一句话：==前面指令的阻塞不影响后面指令的继续前进。==</p>
<h2 id="42-实现方法">4.2 实现方法</h2>
<p>先看一段代码：</p>
<pre tabindex="0"><code>fdiv.d   f0 , f2 , f4         //浮点除法
fadd.d  f10 , f0 , f8         //浮点加法
fsub.d  f12 , f8 , f14        //浮点减法
</code></pre><p>其中div和add中因为f0存在数据依赖，所以add必须阻塞等待div执行完成，但是sub不依赖于div和add，可以先行执行，所以如何才能让sub先行执行呢？
将发射过程分为两个部分：
（1）<strong>发射</strong>——指令译码，检查结构冒险
（2）<strong>读取操作数</strong>——一直等到没有数据冒险后，然后读取操作数</p>
<p>那么疑问又来了，为什么我们要分成两个部分？很好，那这又得说回简单的静态五级流水了，在静态的五级流水中，在ID(译码阶段）检查结构冒险和数据冒险，什么意思勒，就是一定要在无冒险执行时，才会发射，那么也就是说，如果存在冒险，那么就不会发射，就只能等待，上面例子中sub指令就得一直等等等。
那么如果我们分成两部分，还是正常顺序发射，但如果某条指令需要等待操作数的话就先把它暂存到一个地方（这个地方叫保留站），等待操作数可用的时候就立即执行，这样就可以腾出指令执行的通路，后面不相关的指令就可以继续执行，这样就实现了<strong>乱序执行</strong>。</p>
<h4 id="421-cdc6600记分牌scoreboarding">4.2.1 CDC6600记分牌(scoreboarding)</h4>
<p>上面提到了我们通过保留站实现了<strong>乱序执行（out-of-order execution）</strong>，那么可以确定的是，乱序执行的结果就是<strong>乱序完成（out-of-order completion)</strong>。</p>
<h6 id="记分牌的主要思想">记分牌的主要思想：</h6>
<p>（1） 发射前检测结构相关和WAW相关
（2）读操作数前检测RAW相关（即仅在操作数可用时才执行该指令）
（3）写结果前处理WAR相关</p>
<h6 id="记分牌的缺点">记分牌的缺点：</h6>
<p>（1）没有定向数据通路
（2）指令窗口较小，仅局限于基本块内的调度
（3）结构冲突时不能发射
（4）WAR相关是通过等待解决的
（5）WAW相关时，不会进入Issue（发射）阶段
（6）功能部件数较少</p>
<h4 id="422-tomasulo算法">4.2.2 Tomasulo算法</h4>
<p><strong>Tomasulo算法的核心思想：</strong>
（1）跟踪指令的操作数何时可用，以将RAW冒险降至最低；
（2）在==硬件中==引入==寄存器重命名==功能，将WAW和WAR冒险降至最低。</p>
<hr>
<p>另外，还可以对Tomasulo算法进行扩展，用来处理==推测==，通过预测一个分支的输出、执行预测目标地址的指令、在预测错误时采取纠正措施，降低控制依赖的影响。	 Tomasulo算法还可以处理==跨越分支==的重命名问题。</p>
<hr>
<p><strong>寄存器重命名功能实现：</strong>
寄存器重命名功能由==保留站==（reservation station）提供。
<strong>基本思想</strong>：保留站在一个操作数可用时马上提取并缓冲它，这样就不再需要从寄存器中获取该操作数。此外，等待执行的指令会指定保留站为自己提供输入。最后，在对寄存器连续进行写操作时并且重叠执行时，实际只会用到最后一个操作更新寄存器。</p>
<h5 id="为什么使用保留站">为什么使用保留站？</h5>
<p>我们有个疑问，为什么使用保留站，而不是使用一个集中式的寄存器堆呢？
原因有两个：
（1）冒险检测和执行控制是分布式的：每个功能单元保留站中保存的信息，决定了一条指令什么时候开始在该单元中执行；
（2）结果将直接从缓冲它们的保留站中传递给功能单元，而不需要经过寄存器。是通过公共数据总线（CDB）完成的，它允许同时载入所有等待一个操作数的单元。</p>
<p><img src="https://img-blog.csdnimg.cn/0e2dcfccf80e43679beb28f80b33de05.png" alt="使用Tomasulo算法的浮点单元的基本结构">
<strong>保留站中几个字段解释：</strong>
·Op—— 对源操作数S1和S2执行的运算；
·Qj 、Qk —— 将生成相应源操作数的保留站；当取值为0时，表明已经可以在Vj或Vk中获取源操作数，或者不需要源操作数；
·Vj 、Vk —— 源操作数的值。<strong>注意，对于每个操作数，V字段或Q字段中只有一个是有效的</strong>
· Busy —— 指明这个保留站及其相关功能单元已被占用；
<strong>寄存器堆中的字段：</strong>
· Qi —— 空表示寄存器值可用，否则保存产生寄存器结果的保留站号。</p>
<hr>
<h3 id="执行流程解释">执行流程解释：</h3>
<p>这里为了帮助理解，我用胡伟武老师《体系结构》的课件中的一个例子：</p>
<pre tabindex="0"><code>DIV.D F0,F1,F2
MUL.D F3,F0,F2
ADD.D F0,F1,F2
MUL.D F3,F0,F2
</code></pre><p>指令队列按照FIFO顺序维护，以确保顺序发射。如果有一个匹配的保留站为空，则将这条指令发射到这个站中，如果操作数值已经存在于寄存器，也一并发送到站中。如果没有空闲保留站，则存在结构冒险，该指令会停顿，直到有保留站或缓冲区被释放为止。（下图中的左上角的标号不用管，标号的时候略过5号了，顺序是对滴～）</p>
<p><img src="https://img-blog.csdnimg.cn/98ed57060c784919af29f34c5fd11a7b.jpeg" alt="请添加图片描述">
<img src="https://img-blog.csdnimg.cn/15e6167fa7d44f04a4ec45c0850e4ded.jpeg" alt="请添加图片描述">
<img src="https://img-blog.csdnimg.cn/638e4b765b674b9188eeeb59d4e2b3b4.jpeg" alt="请添加图片描述">
<img src="https://img-blog.csdnimg.cn/f2296080949b4c7d84a4fbc477935a23.jpeg" alt="请添加图片描述">
<img src="https://img-blog.csdnimg.cn/1713e7dd2d8145e8afaa59ed2ab8b261.jpeg" alt="请添加图片描述">
<img src="https://img-blog.csdnimg.cn/899c36dab1c74eb3a394e41297dcb2eb.jpeg" alt="请添加图片描述">
<img src="https://img-blog.csdnimg.cn/4d337dd4005a41a5992db7ac1b569928.jpeg" alt="请添加图片描述">
<img src="https://img-blog.csdnimg.cn/1fa37267367e45c4939ebb3fb8a48de9.jpeg" alt="请添加图片描述"></p>
<h2 id="总结">总结</h2>
<p>后续再更新ROB和分支预测等内容，觉得写的还可以，点赞关注吧。。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
